ctrl+shift+v markdown预览
# 数据理解
## 数据集分析
- train.csv
    - source_system_tab:  指手机客户端的不同功能区，包括搜索框、本地音乐等。  
 the name of the tab where the event was triggered. System tabs are used to categorize KKBOX mobile apps functions.   
 For example, tab my library contains functions to manipulate the local storage, and tab search contains functions relating to search.
    ```
        > table(test$source_system_tab)
        discover      explore  listen with   my library notification         null        radio       search     settings 
        871068        66023        98628      1019492         2124         3346       212765       277615          633 
    ```
    - source_screen_name:放歌的时候用户在哪一个界面（比如主界面是付钱续费，用户在下面的播放栏点了一下切歌）  
        name of the layout a user sees.
    ```
        > table(test$source_screen_name)
          Album more          Artist more              Concert       Discover Chart     Discover Feature       Discover Genre 
              176129               110999                   13                78999                93401                41617 
        Discover New              Explore  Local playlist more           My library    My library_Search Online playlist more 
                5277                27872               845115                25559                 2114               529807 
         Others profile more      Payment        People global         People local                Radio               Search 
               90457                   12                    1                   13               211201               121982 
         Search Home        Search Trends    Self profile more              Unknown 
                4705                 4883                  131                23620 
    ```
    - source_type: 在手机客户端上初次播放音乐的进入点(entry point). 


    ```        
        > table(test$source_type)
                 album                 artist            listen-with          local-library         local-playlist 
                195190                    428                  84499                 582346                 294537 
        my-daily-playlist        online-playlist                  radio                   song    song-based-playlist 
                  2023                 774532                 215164                 129153                  87179 
        top-hits-for-artist topic-article-playlist 
                179360                   5082
    ```
- songs.csv
    - language
        - 估计：24是粤语；
    ```
    > table(songs$language)
        -1       3      10      17      24      31      38      45      52      59 
    639467  106295   15482   92518   41744   39201    2385   14435 1336694    8098 
    > head(songs[songs$language==24,-1],4)

    # A tibble: 4 x 6
    song_length genre_ids            artist_name   composer                       lyricist language
            <int>     <chr>                  <chr>      <chr>                          <chr>    <dbl>
    1      212276       465  謝霆鋒 (Nicholas Tse)       <NA>                           <NA>       24
    2      208004       465    鄭伊健 (Ekin Cheng)     陳光榮                         劉卓輝       24
    3      242811       465   鄭秀文 (Sammi Cheng) Gigi Leung Keith Chan| Keith Chan Siu Kei       24
    4      248871       465 張國榮 (Leslie Cheung)       <NA>                           <NA>       24
    ```
    - song_length


# 清华大佬的brief intro
1. Analysis of the Problem 问题分析  
- 这个问题类似于点击率价值判断问题，重听行为类似于购买，第一次听歌相当于点击。
    - 搜索相关资源时， "CTR prediction"是一个更加合适的关键词，相较于"recommendation"。  (since CTR/CVR predictions share similar models) 
    - 基于潜在因素或近邻聚合过滤器的推荐方法不适合这一问题。some recommendation methods like latent-factor based or neighborhood-based collaborative filtering is not the best way for this problem.
- 类似于CVR预测，这一问题当中有如下性质对特征工程很有帮助。
    - Missing not at random 如果一个用户-歌曲匹配对子存在于数据集中，我们可以分辨出用户至少听过一次这首歌。
    - Time-sensitive 因为这些数据本身跨越了一个较长的时间段，从开始到结束有发生变化，这对验证策略validation strategy和特征工程很重要。
2. Overall Framework 总体框架  
- 最终所用的模型由六成LightGBMs和四成NNs构成。
- LightGBMs 和 NNs 都是 bagging ensembles of several predictions with a slightly different subset of features. 
- 使用LightGBMs的情况下，单个模型的最佳成绩是0.74440 on public LB 参数 a learning rate of 0.1 and 0.74460 at 0.05, and bagging ensemble of LightGBMs can reach about 0.74584.
- 将决策树和神经网络结合可以得到很好的boost的理由：  
 决策树是贪婪算法。GBDT is more or less a greedy method. It always captures the head flow first.  
 NNs, in contrast, explore the broad combinations of features, so it's easier for NNs to fit the pattern in the tail flow.
3.  验证策略Validation Strategy  
使用了最后20%的数据作为验证集。 the validation set.   
提交时使用的特征包括由test.csv中所得到的。
for validation, I use the features generated by the train.csv only, and for submission, I use the features generated with both train.csv and test.csv.
4. 神经网络NN Models  
模型结构见网页上的图片。  
    1. Field-aware  
    输入可以分为用户、歌曲、环境context三个field。
    2. 对类别变量使用L2正则化 Use trainable embeddings with L2 regularization for categorical features
    3. 后略
5. LightGBM
    - 最终的LGBM模型使用了大概400个特征。  
    - GBDT 很强。 A simple GBDT can beat an ensemble of 30 carefully-designed NNs (of course GBDT is an ensemble model itself). While the advantage of NNs is that it's very fast compared with LightGBM. 
## 特征工程 Feature Engineering  
Here are some important features that I found.
- Conditional probability features 条件概率特征  
我的理解是，这条记录里有一个msno，然后遍历这个msno的所有记录，计算他使用本记录里的source_type的概率。  
P(source_type|msno), P(source_screen_name|msno), P(source_system_tab|msno), P(source_type|song_id), P(source_screen_name|song_id), P(source_system_tab|song_id), P(artist_name|msno), P(language|msno), P(first_genre_id|msno)  
 MLE probability效果最好.  
这个办法在该分类变量的值域特别广时非常有用。如 msno and song_id.

- Timestamp 时间戳  
使用记录的序号作为一个特征。
Since the data is ordered chronologically, we can use the index as a timestamp.

- 矩阵的奇异值分解 SVD features with 用户歌曲矩阵和用户歌手矩阵 user-song matrix and user-artist matrix  
As mentioned before, the data is missing-not-at-random, so constructing a user-song matrix and user-artist matrix and use SVD to get embeddings for users/songs/artist can help significantly.  
LDA and Gamma-Poisson Factorization 的结果比不过SVD.

- 其它特征 Other features
Including some count features（记数，如该国家对应的歌曲有多少）, last song features（该用户听过的前一首歌）, and next song features.

## Some Methods that Didn't Work

- Pseudo labeling 伪标签  
Using the ensemble predictions as pseudo labels for test set is helpful significantly, while the lost diversity just makes the results after ensemble not improving at all. 
- DART mode  
DART mode of LightGBM is really slow, and uncorrelated with gbdt. 
- FFM  
- Give larger weights to more recent records  After adding the timestamp to the feature set, this can only give very tiny help. So I didn't use it anymore.
- Deep&Wide model
# 清华大佬的解决方案
## 处理 id isrc 
### 未知函数：
- groupby() df的分组，分成以key为划分的若干个组。
- to_dict()
### isrc编码规则
1. [0:2]  
国家码(Country Code)音像出版者所在国家伪代码，由2个大写字母组成。按ISO166《国家和地区名称代码》国际标准的规定给出。如SE=SWEDEN(瑞典)。  
2. [2:5]  
出版者码(Company Code)为对本音像记录拥有第一版权的公司代码，又称第一版权拥有者代码(First owner code)，由3位字符组成，其中数字的取值范围为0~9，字母的取值范围为A~H，J~N和P~Z。在字母中不含“I”和“O”是为避免与数字1和0混淆。在一般情况下，3个字符中至少包含1个字母或数字。根据排列组合规则计算．一个国家中的出版者代码共可设3X(10X10X24+10X24X24)=24824(个)  
3. [5:7]  
录制年码(Year of Recording Code)为音像记录的录制完成或音像制品的首发年份代码，取该年份的后两位数字。例如92代表1992年，录制年码由音像出版者确定。  
4. 记录码(Recording Code)标识一种音像记录在该录制年内的顺序编码，由出版者设定为3位或4位数字。  
5. 记录项码(Recording Item Code)标识一个音像记录中每一项可独立的节目的代码，由2位或1位数字组成。  
### isrc与count
- isrc_missing
```
song['cc_song_cnt'] = song['cc'].apply(lambda x: song_cc_cnt[x] if not np.isnan(x) else None)
```
- 该歌曲对应的国别/发行商/年份所发行的歌曲数目
- 听过该国家/发行商/年份的歌曲的会员数量
- 对count变量取对数
```
for feat in features:
    song[feat] = np.log1p(song[feat])
```
舍弃歌名和isrc
### svd process
#### coo_matrix
```
coo_matrix((data, (row, col)), shape=(4, 4)).toarray()
```
- 未设定shape的情况下，matrix的shape由row和col的最大值决定。
- 可表出songs和msno的匹配情况。
#### svds 稀疏矩阵的处理
```
[u, s, vt] = svds(rating, k=n_component)
```
- 将稀疏矩阵rating分解为 U @ S @ Vt
- k=n_component是奇异值的数量
- 中间的S是对角矩阵
```
numpy.diag(x)
```
- x是矩阵 获得对角元素
- x是数组 构建对角矩阵
- 后面就看不懂了……
#### time stamp
 前辈：'我们可以发现train数据集大约在2016年8月15日到2017年1月13日，test数据集在1月13到2月28日 '
#### before data 和 after data
- 某个msno，上一次听歌的歌名、来源、屏幕类型、时间序列位置。
- 若该会员第一次出现，则before的stamp为nan。
- after data 同理，只不过循环从末尾开始遍历。
#### experiment 获得条件频数和条件概率
- ['msno_' + feat + '_cnt'] 某会员与某特征（如歌手）相匹配的记录在整个数据集中出现的频数。
- ['msno_cnt'] 某会员在整个数据集中共有多少条听歌记录。/该会员的频次。
- ['msno_feat_prop'] 某会员听某一首歌的频数占全部听歌行为的比重。
- msno对应的feat包括['artist_name', 'first_genre_id', 'xxx', 'language', 'yy', 'source']
- 同时有 group by ['song_id'] 
- song_id对应的feat包括 ['source_system_tab', 'source_screen_name', 'source_type']
# 我们能做的
## 序列化
把song_id和msno使用LaberEncoder转化掉
## 特征工程
- 会员序号和歌曲编码的分解
- genre_id的聚类？
- 记录序号（时间戳）
- 匹配次数与条件概率
    -  歌曲-会员 
    -  歌手-会员 
    -  歌曲-环境
- 歌曲或会员上一次或下一次出现时所在记录的某些特征
## Cross Validation
## Boosting & Bagging